1. 버블정렬:
    - 버블정렬은 단순히 인접한 두 개의 원소를 확인하여 정렬이 안 되어 있다면 위치를 서로 변경한다.
    - 서로 인접한 두 원소를 비교하는 형태가 거품과 같다고 하여 붙여진 이름이다.
    - 시간 복잡도 O(N^2)으로 비효율적인 정렬 알고리즘 중 하나이다.
    - 선택정렬이 가장 작은 원소가 맨 왼쪽으로 가는 방식이었다면 버블정렬은 가장 큰 원소가 가장 오른쪽으로 가는 방식

2. 버블 정렬 동작방식
    - 각 단계에서는 인접한 두 개의 원소를 비교하여, 필요시 위치를 변경한다.
    - 첫 째와 둘 째를 비교, 둘 째와 셋 쨰를 비교, 셋 째와 넷 쨰를 비교하는 방식이다.
    - 한 번의 단계가 수행되면, 가장 큰 원소가 맨 뒤로 이동한다.
    - 따라서 그 다음 단계에서는 맨 뒤로 이동한 데이터는 정렬에서 제외한다.
    * 각 단계를 거칠 때마다 가장 큰 값을 하나씩 확실하게 결정하는 것으로 이해할 수 있다.

3. 버블 정렬 예시

[9, 8 , 2, 4, 3]

1단계 : ["9", 8, 2, 4, 3] -> [8, "9", 2, 4, 3] -> [8, 2, "9", 4, 3] -> [8, 2, 4, "9", 3] -> [8, 2, 4, 3, "9"]

9는 이미 비교가 완료됐기 떄문에 비교에서 제외된다. 8은 3까지만 비교한다.

...

4단계: [2, 3, 4, 8, 9] -> [2, 3, 4, 8, 9]






구현은 쉽지만 선택정렬보다도 느리다. 데이터의 개수가 많다면 쓰지 않는 것이 좋다.



5. 버블정렬의 소스 코드 예시

/* 1) 버블 정렬의 수행 시간 측정*/
// 0부터 999까지의 정수 30000개를 담은 배열 생성

const bubbleSort = require("./bubbleSort");

let arr = Array.from({ length: 30000 }, () => Math.floor(Math.random() * 1000));

// getTime(): 1970-01-01부터의 시간차를 ms단위로 계싼
startTime = new Date().getTime();
bubbleSort(arr);
endTime = new Date().getTime();

// 시간차 출력
console.log("버블 정렬 소요 시간: ", endTime - startTime, "ms");

/* 2) 이미 정렬된 배열에 대한 버블 정렬의 수행 시간 측정 */
// 값이 7인 정수 30000개를 담은 배열 생성

arr = Array.from({ length: 30000 }, () => 7);

// getTime(): 1970-01-01부터의 시간차를 ms 단위로 계산
startTime = new Date().getTime();
bubbleSort(arr);
endTime = new Date().getTime();
console.log("endTime: ", endTime);

// 시간차 출력
console.log(
  "정렬된 배열에 대한 버블 정렬 소요 시간: ",
  endTime - startTime,
  "ms"
);

// $ node bubbleSOrtEx01.js
// 버블 정렬 소요 시간:  2793 ms
// endTime:  1712239305935
// 정렬된 배열에 대한 버블 정렬 소요 시간:  1043 ms



6. 버블 정렬의 시간 복잡도
    - 최악의 경우 시간복잡도 O(N^2)를 보장한다.
    - 이미 정렬된 배열에 대해서 모든 비교가 필요하므로 굉장히 비효율적인 정렬 알고리즘이다.