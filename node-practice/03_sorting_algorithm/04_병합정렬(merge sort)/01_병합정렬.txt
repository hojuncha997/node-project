1. 병합정렬(merge sort):
 병합정렬은 전형적인 분할정복(divide and conquer) 알고리즘이다.

    분할정복
    -1. 분할(divide) : 큰 문제를 작은 부분 문제(쉬운 문제)로 분할한다.
    -2. 정복(conquer): 작은 부분 문제를 각각 해결한다.
    -3. 조합(combine): 해결한 부분 문제의답을 이용하여 다시 큰 문제를 해결한다.

    - 분할 정복은 일반적으로 재귀 함수를 이용해 구현한다.
    - 큰 문제를 작은 문제로 분할하는 방식이 동일한 경우가 많기 때문이다.
    - 더이상 쪼갤 수 없는 크기가 될 때까지 계속하여 분할한다.


    분할정복의 단점
    - 일반적으로 재귀함수를 사용한다는 점데서 함수 호출 횟수가 높다.
    - 이는 오버헤드로 이어진다.
    - 재귀함수의 경우에는 스스로를 호출하게 되면 자신이 호출한 함수가 끝날 때까지 자신이 끝나지 않는다.
    - 이러한 구조는 스택과 유사하며, 마지막에 호출된 함수가 가장 먼저 끝나야 그 전에 들어온 함수가 나올 수 있다는 점에서
        재귀함수는 컴퓨터의 스택 메모리 영역에 계속해서 정볼르 넣는 것과 같다고 볼 수 있다. 이것이 오버헤드로 이어질 수 있다는 것이며, 분할 정복의 단점으로 지적되곤 한다.


2. 병합정렬의 특징
    - 시간 복잡도 O(NlogN)을 보장하는 빠른 정렬 알고리즘 중 하나이다.
    - 따라서 데이터 개수가 많을 때는 병합정렬의 아이디어를 이용해서 정렬을 수행할 수 있다.

3. 병합 정렬의 동작 방식

    -1. 분할(divide) : 정렬할 배열(큰 문제)을 같은 크기의 부분 배열(작은 문제) 2개로 분할한다.
    -2. 정복(conquer): 부분 배열을 정렬한다. (작은 문제를 해결한다)
    -3. 조합(combine): 정렬된 부분 배열을 하나의 배열로 다시 병합한다.(여기서 실질적인 정렬이 이루어진다)


    예시)

    정렬대상배열:      [8,4,6,1,2,5,7,3]
    분할 단계:         [8,4,6,1]               [2,5,7,3]
    분할 단계:         [8,4]   [6,1]           [2,5]   [7,3]
    분할 단계:         [8] [4] [6] [1]         [2] [5] [7] [3]
    
    정복/조합 단계:    [4,8]   [1,6]           [2,5]   [3,7]
    정복/조합 단계:    [1,4,6,8]               [2,3,5,7]
    정복/조합 단계:    [1,2,3,4,5,6,7,8]


    3.1. 병합 정렬의 동작 방식 - 정복(Conquer)
        - 각 부분 배열은 이미 정렬된 상태로 본다.
        - 각 부분 배열에 대하여 첫 째 원소부터 시작하여 하나씩 확인한다.
        - 총 원소의 개수가 N개일 때, O(N)의 시간 복잡도가 요구된다.

        부분 배열이 정렬된 상태이기 때문에, 인덱스를 사용하여 각 배열의 가장 작은 값부터 차례로 비교한다.
        둘 중 더 작은 원소가 조합될 결과배열의 앞 순서에 오게 된다.
        즉, 두 개의 배열 사이에 가장 작은 값부터 서로 비교하며, 하나가 먼저 끝나면 다머지는 그대로 붙여넣어 결과배열을 만드는 것이다.
        이런 과정에서 원소를 하나씩 확인하기 떄문에 최대 N번 까지의 시간복잡도가 요구된다고 할 수 있는 것이다.

    3.2. 병합정렬의 시간복잡도(time complexity)
    - 직관적으로 생각했을 때 높이가 O(logN)이고 너비가 O(N)인 정사각형과 유사하다.
    - 따라서 최악의 경우 시간복잡도는 O(logN)이다.
    - 장점: 최악의 경우에도 O(NlogN)을 보장할 수 있다는 점에서 효율적이다.
    - 단점: 일반적인 경우, 정복(conquer)과정에서 임시 배열이 필요하다