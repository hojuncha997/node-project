1. 트리(tree)

- 트리는 가계도와 같이 계층적인 구조를 표현할 때 사용할 수 있는 자료구조다.
- 나무(tree)의 형태를 뒤집은 것과 같이 생겼다.
- 이 때 뿌리에 해당하는 것은 root node라고 부른다.
- 각각의 노드를 자식 노드를 가질 수 있다.

2. 트리 용어 정리

- 루트 노드(root node): 부모가 없는 최상위 노드
- 단말 노드(leaf node): 자식이 없는 노드

- 트리에서는 부모와 자식 관계가 성립한다.
- 형제 관계: 같은 부모를 가지고 있는 관계

- 깊이(depth): 루트 노드에서의 길이(length). 최단거리라고도 볼 수 있다.
- 이 때 길이(length)란 출발 노드에서 목적지 노드까지 거쳐야 하는 간선의 수를 의미한다.
- 트리의 높이(height)는 루트 노드에서 가장 깊은 노드까지의 길이를 의미한다.

- 참고로 트리에서는 특정 노드에서 특정 노드로 가기 위한 경로가 "하나"만 존재한다.

3. 이진 트리 (Binary Tree)
- 이진 트리는 최대 2개의 자식을 가질 수 있는 트리를 말한다.



==========================================

4. 우선순위 큐(priority Queue)

- 우선순위 큐는 우선순위에 따라서 데이터를 추출하는 자료구조다.
- 컴퓨터 운영체제, 온라인 게임 매칭 등에서 활용된다.
- 우선순위 큐는 일반적으로 힙(heap)을 이용해 구현한다.
- 우선순위 큐는 heap 자료구조를 사용해서 만들 수 있고, heap은 트리 자료구조를 사용해서 구현할 수 있다.


자료구조        추출되는 데이터
-------        --------------
스택            가장 나중에 삽입된 데이터
큐              가장 먼저 삽입된 데이터
우선순위 큐      가장 우선순위가 높은 데이터


즉, 우선순위 큐는 개발자가 별도로 명시해 놓은 우선 순위가 높은 데이터부터 먼저 꺼내져서 해당 데이터가 처리되는 것으로 이해할 수 있다.




5. 우선순위 큐를 구현하는 방법

- 우선순위 큐는 다양한 방법으로 구현할 수 있다.
- 데이터의 개수가 N개일 때, 구현 방식에 따른 시간 복잡도는 아래와 같다.



우선순위 큐 구현 방식     삽입 시간     삭제 시간
-------------------     ---------     --------
리스트 자료형             O(1)         O(N)
힙(Heap)                 O(logN)      O(logN)


단순히 리스트나 배열 같은 자료형으로 우선순위 큐를 구현한다고 하면, 예르 들어 JS에서 배열로 우선순위 큐를 구현한다면,
삽입할 때는 push를 이용해 삽입한다고 하더라도 꺼낼 떄는 어떤 것이 가장 우선순위가 높은지를 확인해야 한다.
따라서 하나씩 확인해야 하기 떄문에 삭제 시간이 N만큼 소요될 수 있다.

하지만 heap을 이용한다고 하면 삽입시간이나 삭제시간 모두 로그 N의 시간 복잡도를 보장할 수 있다.
이것이 바로 트리를 이용하는 이유이다.

- 일반적인 형태의 큐는 선형적인 구조를 가진다.
- 반면에 우선순위 큐는 비선형적인 이진 트리(binary tree)구조를 사용하는 것이 일반적이다.


6. 이진트리의 종류

  6.1. 포화 이진트리(Full Binary Tree)
  - 포화 이진트리는 리프 노드를 제외한 '모든' 노드가 두 자식을 가지고 있는 트리다.


  6.2. 완전 이진트리(Complete Binary Tree)
  - 완전 이진트리는 모든 노드가 왼쪽 자식부터 차근차근 채워진 트리다.
  - 즉 제일 왼쪽부터 차근차근 아래로 내려가면서 채워진 트리 형태이다.


  6.3. 높이균형 트리(Height Balanced Tree)
  - 루트 기준으로 봤을 때 왼쪽 자식 트리와 오른쪽 자식 트리의 높이가 1 이상 차이 나지 않는 트리다.




==========================================

7. 힙(Heap)

- 힙은 원소들 중에서 최댓값 혹은 최솟값을 빠르게 찾아내기 위해 설계된 자료구조다.
- 최대힙(max heap): 값이 큰 원소부터 추출한다.
- 최소힙(min heap): 값이 작은 원소부터 추출한다.
- 힙은 원소의 삽입과 삭제를 위해 O(logN)의 수행시간을 요구한다.
- 단순한 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일하다. 예를 들어 최소 힙에 들어갔다 나오면 작은 순서대로 나오게 된다.
- 이 경우 시간 복잡도는 O(NlogN = N * logN)이다.


8. 힙의 특징

- 힙은 "완전 이진트리" 자료구조를 따른다.
- 힙에서는 우선순위가 높은 노드가 루트에 위치한다.
- 힙의 삽입과 삭제 연산을 수행할 때를 고려해 보자.
- 직관적으로, 거슬러 갈 때마다 처리해야 하는 범위에 포함된 원소의 개수가 절반씩 줄어든다
- 따라서 삽입과 삭제에 대한 시간 복잡돈느 O(logN)이다.

  8.1. 최대힙
  - 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크다.
  - 루트 노드가 가장 크며 값이 큰 데이터가 우선순위를 가진다.

  8.2. 최소힙
  - 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작다.
  - 루트 노드가 가장 작으며, 값이 작은 데이터가 우선순위를 가진다.

  


9. 최소 힙 구성 함수: Heapify

- (상향식) 자식에서부터 부모로 거슬로 올라가며, 부모보다 자신이 더 작은 경우에 자신과 부모의 위치를 교체한다.
- 최소 힙 성질(작은 값이 부모인 성질)이지 않은 경우 자식과 부모의 위치를 바꾼다.
- 힙을 만든다는 의미에서 Heapify라는 함수명을 붙이는 것이 일반적이다.




10. 힙에 새로운 원소가 삽입될 때 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있다.

11. 힙에서 새로운 원소가 삭제될 떄

- 원소가 제거되었을 때 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있다.
- 원소를 제거할 때는 가장 마지막 노드가 루트 노드의 위치에 오도록 한다.
- 즉, 루트를 먼저 제거하고 가장 마지막 위치의 원소를 루트에 위치에 오도록 바꿔준다.
- 그 뒤에는 루트 노드에서 하향식으로 (더 작은 자식노드로) heapify()를 진행한다.

12. logN이 유지되는 이유

- 따라서 삽입과 삭제에 대한 시간 복잡도는 O(logN)이다.
- 직관적으로 거슬러 올라갈 때마다 처리해야 하는 범위에 포함된 원소의 개수가 절반씩 줄어들기 떄문이다.
- 따라서 삽입과 삭제가 자주 일어나는 상황에서 이러한 힙은 우선순위 큐의 목적으로 사용되기에 매우 적합하다.



13. Javascript의 heap 라이브러리
- JS느 기본적으로 우선순위 큐를 라이브러리로 제공하지 않는다.
- 최단 경로 알고리즘 등에서 heap이 필요한 경우 "별도의 라이브러리"를 사용해야 한다.


https://github.com/ndb796/priorityQueuejs
의 index.js 파일을 사용할 수 있다.



// 최대힙
let pq = new PriorityQueue(function(a, b) {
  return a.cash - b.cash;
});

pq.enq({cash: 250, name: 'Doohyun Kim'});
pq.enq({cash: 300, name: 'Guildong Hong'});
pq.enq({cash: 150, name: 'minchul Han'});

console.log(pq.size()); // 3
console.log(pq.deq()); // {cash: 300, name: 'Guildong Hong'} 제거
console.log(pq.size()); // 2

