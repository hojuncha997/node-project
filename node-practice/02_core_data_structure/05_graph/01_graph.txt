JS의 배열을 이용해서 그래프를 사용한다.

1. graph(그래프)의 표현:
  - 그래프란 사물을 정점(vertex 또는 node)와 간선(edge, 노드 사이의 통로, 연결선)으로 나타내기 위한 도구다.

  - 그래프는 두 가지 방식으로 구현할 수 있다.

    -- 인접행렬(adjacency matrix): 2차원 배열을 사용하는 방식
    -- 인접 리스트(adjacency list): 연결리스트를 이용하는 방식

  네비게이션 프로그램을 개발한다고 할 때 하나의 장소는 정점으로 표현될 수 있으며 그러한 정점과 이어주는 통로나 다리를 간선이라고 할 수 있다.

 
2. 인접 행렬(adjacency matrix) 방식 :
  - 인접행렬에서는 그래프를 2차원 배열(즉 행렬)로 표현한다. 마치 빙고판과 같은 모습이다.
  - 일반적으로 행이 시작노드로 표현되고, 열이 도착 노드로 표현된다.
  - 자신에서 자신 노드로 이동하는 것은 머물러 있다고 볼 수 있기 떄문에 거리가 0이다.
  - 존재하지 않는 간선은 무한이라고 볼 수 있다.

  2.1. 무방향 무가중치 그래프
    - 모든 간선이 방향성을 가지지 않는 그래프를 무방향 그래프라고 한다.
    - 간선에 가중치가 없기 떄문에, 즉 비용이 명시돼 있지 않기 떄문에 연결여부만 알 수 있다.
    - 모든 간선에 가중치가 없는 그래프를 무가중치 그래프라고 한다.
    - 무방향 비가중치 그래프가 주어졌을 때 연결되어 있는 상황을 인접 행렬로 출력할 수 있다.
    - 자기 자신과의 연결과, 연결되지 않은 경우는 0으로 표현한다.

  2.2. 방향 가중치 그래프
    - 모든 간선이 방향을 가지는 그래프를 방향 그래프라고 한다.
    - 모든 간선에 가중치가 있는 그래프를 가중치 그래프라고 한다.
    - 방향 가중치 그래프가 주어졌을 때 연결되어 있는 상황을 인접행렬로 출력할 수 있다.
    - 즉 연결돼 있다고 해도 화살표가 그 쪽을 향하고 있지 않다면 0이라고 할 수 있다.
    - 만약 다른 노드로 방향을 향하고 있고, 그 가중치가 7이라면 [0,0,7,0] 이런 식으로 표현할 수 있다.
    - 연결돼 있는데 양쪽 다 서로를 향하고 있지 않다면 그냥 그 가중치를 적어주면 된다.

3. 인접 리스트(adjacency list) :
  - 인접 리스트에서는 그래프를 리스트로 표현한다.
  - 각각 노드마다 자기와 연결돼 있는 노드를 아래와 같이 리스트의 원소 형태로 표현한다.
    0:[(1, 3), (2, 7)]  -> 0번 노드가 1번 노드로 이동이 가능하며 그 비용이 3이다. 0번 노드가 2번 노드로 이동 가능하며 비용은 7이다. 자기 자신으로의 이동은 아예 원소로 들어가 있지 않다.
    1:[(0, 3)] -> 1번 노드에서 0번 노드로 가기 위한 비용은 3이다.
    2:[(0, 7)] -> 2번 노드에서 0번 노드로 가기 위한 비용이 7이다.

    2차 행열(n*n행렬)이 필요하지 않기 떄문에 상대적으로 메모리 효율적이다.


  3.1. 무방향 무가중치 그래프
    - 모든 간선이 방향성을 가지지 않는 그래프를 무방향 그래프라고 한다.
    - 모든 간선에 가중치가 없는 그래플르 무가중치 그래프라고 한다.
    - 무방향 비가중치 그래프가 주어졌을 때 연결돼 있는 상황을 인접리스트로 출력할 수 있다.

    let graph = [
      [1, 2],     -> 0번 노드에서 1번 노드와 2번 노드로 이동이 가능하다.
      [0, 2],     -> 1번 노드에서 0번 노드와 2번 노드로 이동이 가능하다.
      [0, 1, 3],  -> 2번 노드에서 0번 노드, 1번 노드, 3번 노드로 이동이 가능하다
      [2]         -> 3번 노드에서 2번 노드로 이동이 가능하다
    ];

    console.log(graph);


  3.2. 방향 가중치 그래프
    - 모든 간선이 방향을 가지는 그래프를 방향 그래프라고 한다.
    - 모든 간선에 가중치가 있는 그래프를 가중치 그래프라고 한다.
    - 방향 가중치 그래프가 주어졌을 때 연결돼 있는 상황을 인접리스트로 출력할 수 있다.

    let graph = [
      [(2, 7)],           -> 0번 노드에서 2번 노드로 이동 가능하며 그 비용은 7이다.
      [(0, 3), (2, 8)],   -> 1번 0번 노드로 이동 가능하며 비용은 3이다. 2번 노드로 이동 가능하며 그 비용은 8이다.
      [(1, 8)],           -> 2번 노드에서 1번 노드로 이동 가능하며 그 비용은 8이다.
      [(2, 4)],           -> 3번 노드에서 2번 노드로 이동 가능하며 그 비용은 4다.
    ];
    console.log(graph);

4. 그래프의 시간 복잡도

  4.1. 인접행렬: 모든 정점들의 연결 여부를 저장해 O(V^2)의 공간을 요구한다.
    - 공간 효율성이 떨어지지만, 두 노드의 연결 여부를 O(1)에 확인할 수 있다. 즉, 상수 시간에 확인이 가능하다

  4.2. 인접 리스트: 연결된 간선 정보만을 저장하여 O(V+E)의 공간을 요구한다.
    - 공간 효율성이 우수하지만, 두 노드의 연결 여부를 확인하기 위해 O(V)의 시간이 필요하다.

    ---------- ----------------- -----------------
    |         | 필요한 메모리    |  연결 여부 확인  |
    ---------- ----------------- -----------------
    | 인접행렬 |    O(V^2)       |    O(1)        |
    ---------- ----------------- -----------------
    |인접리스트|    O(V + E)     |    O(1)        |
    ---------- ----------------- ---------------- 


5. 인접행렬 VS. 인접 리스트

  - 최단 경로 알고리즘을 구현할 떄, 어떤 자료구조가 유용할까?
  - 각각 근처 노드와 연결돼 있는 경우가 많으므로 간선 개수가 적어 인접 리스트가 유리하다.
  - 따라서 최단경로 알고리즘을 구현할 때는 일반적으로 인접 리스트를 사용하곤 한다.
 

    
     