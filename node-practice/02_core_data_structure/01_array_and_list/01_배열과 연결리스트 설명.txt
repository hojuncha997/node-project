1. 배열

배열은 가장 기본적인 자료구조
- 일반적으로 같은 성질을 가진 원소가 연속해서 담기는 경우가 많다.
- 배열은 인덱스가 존재하며 직접적으로 접근 가능하다. 인덱스를 통해 메모리에서 값을 얻는 수행시간: O(1) 상수시간


배열의 특징
- 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당된다.
장점: cache 히트 가능성이 높으며 조회가 빠르다.
단점: 배열의 크기를 미리 지정해야 하는 것이 일반적이므로 데이터의 추가 및 삭제에 한계가 있다. 
 (JS는 동적 배열을 사용하기 떄문에 배열에 새로운 원소를 추가하는 등의 작업이 가능하다.)


2. 연결리스트(Linked List)
- 연결리스트는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
- 배열과 다르게 크기가 정해져 있지 않고, 리스트의 크기는 동적으로 변경 가능하다.

장점: 포인터(pointer)를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 간편하다.
단점: 특정 번쨰의 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로 데이터 검색 속도가 느리다.



3. 코딩 테스트를 위한 Javascript 배열

- 여기에서는 직접 연결리스트를 구현하는 방법은 다르지 않는다.
- 연결리스트를 직접 구현하지 않아도 대부분의 알고리즘 문제를 해결하기에는 어려움이 없다.

JS에서는 배열 기능을 제공한다.

- 이 배열 기능일나 프로그래밍 언어에서의 배열로 이해할 수 있다.
- Javascript의 배열은 일반 배열처럼 임의의 인덱스를 이용해 직접적인 접근이 가능하다.
- JS의 배열은 동적 배열의 기능을 제공하며, 맨 뒤의 위치에 원소 추가가 가능하다.


JS의 배열 자료형은 동적 배열이다.
- 배열의 용량이 가득 차면 자동으로 크기를 증가시킨다.
- 내부적으로 포인터를 사용하여 연결 리스트의 장점도 가지고 있다.
- 배열 또는 스택의 기능이 필요할 때 사용할 수 있다.
* queue의 기능을 제공하지 못한다.(비효율적)
* 따라서 queue의 기능이 필요할 직접 구현해서 사용해야 한다.

JS는 대괄호를 이용하거나 new Array()를 이용해 배열을 생성할 수 있다.

let arr = [];
let arr = new Array();

JS에서 배열은 일반적인 변수 외에 객체도 담을 수 있다.

JS에서는 임의의 크기를 가지는 배열을 만들 수 있다.
- 원하는 값을 직접 입력하여 초기화 할 수 있다.
- 크기가 N인 1차원 배열을 만드는 방법은 아래와 같다.

// 원하는 값을 직접 입력하여 초기화 : [0, 1, 2, 3, 4]
let arr1 = [0, 1, 2, 3, 4];

// 하나의 값으로 초기화 : [7, 7, 7, 7, 7]
let arr2 = Array.from({length: 5}, () => 7);


크기가 n * m 인 2차원 리스트(배열) 만들기

// 1. 원하는 값을 직접 입력하여 초기화
let arr1 = [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11],
]

// 2. Array.from() 사용해서 만들기
let arr = Array.from(Array(4), () => new Array(5))

console.log(arr)


출력:

[
    [ <5 empty items> ],
    [ <5 empty items> ],
    [ <5 empty items> ],
    [ <5 empty items> ]
]

//3. 반복문을 이용해 2차원 배열을 초기화 할 수 있다.

// 반복문을 이용해 배열 초기화
let arr2 = new Array(3);                        //원소를 3개 담는 배열
for (let i = 0; i < arr2.length; i++) {         // i는 0부터 2까지 증가
    arr2[i] = Array.from(                       // 새로운 배열 할당
        { length: 4},
        (undefined, j) => i * 4 + j
    );
}

console.log(arr2)

실행 결과:
[
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11],
] 



JS의 배열은 동적 배열이다.
- 배열의 생성된 이후에도 배열의 크기를 임의로 변경할 수 있따.
- push()메서드를 통해 배열의 가장 뒤쪽에 새로운 원소를 추가할 수 있다.

let arr = [5, 6, 7, 8, 9];
arr.length = 8;
arr[7] = 3;
arr.push(1)

for (let x of arr) {
    console.log(x)
}

실행 결과:
5
6
7
8
9
undefined
undefined
3
1


4. Javascript 배열의 대표적인 메서드를

4.1. concat() 

:  여러 개의 배열을 이어 붙여서 합친 결과를 반환한다. O(N)

let arr1 = [1,2,3,4,5];
let arr2 = [6,7,8,9,10];
let arr = arr1.concat(arr2, [11,12], [13]);
console.log(arr)

출력결과:

[ 1,2,3,4,5,6,7,8,9,10,11,12,13]




4.2. slice(left, right)

: 특정 구간의 원소를 꺼낸 배열을 반환한다. O(N)

slice 메서드는 첫 번째 파라미터로 시작 인덱스를, 두 번째 파라미터로 종료 인덱스를 받으며, 
종료 인덱스의 원소는 결과에 포함되지 않는다.

let arr = [1,2,3,4,5];
let result = arr.slice(2,4); //인덱스 2부터 인덱스 4 전까지의 원소를 새로운 배열로 반환

console.log(result) // [3,4]


4.3. indexOf() 

- 특정한 값을 가지는 원소의 첫 째 인덱스를 반환한다. O(N)
- 만약 해당하는 원소가 없는 경우 -1을 반환한다.

let arr = [7, 3, 5, 6, 6, 2, 1];

console.log(arr.indexOf(5)) // 2
console.log(arr.indexOf(6)) // 3
console.log(arr.indexOf(8)) // -1






5. 연결 리스트(Linked list) : 직접 구현하지는 않을 테지만 개념은 아래와 같다.

- 연결리스트는 각 노드가 한줄로 연결되어 있는 구조다.
- 각 노드는 (데이터, 포인터) 형태를 가진다.
- 포인터: 다음 노드의 메모리 주소를 가리키는 목적으로 사용된다.

- 연결성: 각 노드의 포인터는 다음 혹은 이전 노드를 가리킨다.

- 연결리스트를 이용하면 다양한 자료구조를 구현할 수 있다. 예) 스택, 큐 등
- JS에서는 연결리스트를 활용하는 자료구조를 제공한다.
- 그래서 연결리스트를 실제 구현해야 하는 경우는 적지만 그 원리에 대해서 이해할 필요가 있다.


6. 연결 리스트 VS. 배열

- 연결리스트와 배열을 비교하여 장단점을 이해할 필요가 있다.
- 특정 위치의 데이터를 삭제할 때, 일반적인 배열에서는 O(N) 만큼의 시간이 소요된다.
- 하지만 연결리스트를 사용한다면 단순히 연결만 끊어주면 된다. (삭제한 원소의 내용을 다시 채울 필요가 없다.)
- 따라서 삭제할 위치를 정확히 알고 있는 경우 O(1)의 상수시간이 소요된다.

- 배열에 새로운 원소를 삽입할 때, 최악의 경우 시간복잡도는 O(N)이다. 한칸씩 밀거나 당길 필요가 있다.
- 연결리스트에서는 삽입할 위치를 알고 있다면 물리적인 위치를 한 칸씩 옮기지 않아도 삽입할 수 있다.
- 삭제할 경우에도 마찬가지다.
- 뒤에 붙이는 경우 마지막 노드의 다음 위치에 원소를 넣으면 된다.

